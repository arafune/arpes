"""pyarpes plugin for SpecsLab Prodigy exported .xy files.

Currently, this plugin supports following measurements:
1. Single scan dispersion modes (WAM, LAD, MAD, HAD).
2. Single scan magnification modes eV vs x.
3. Polar maps counts as a function of detector angles phi and
motorized polar angle phi.
TODO: Add the support for azimuthal (chi) maps.
"""
from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING, Literal, TypedDict, cast

import numpy as np
import xarray as xr

if TYPE_CHECKING:
    from numpy.typing import NDArray

THETA_MAP_DIMENSION = 3

Measure_type = Literal["FAT", "SnapshotFAT", "Magnification"]
__all__ = ["load_xy"]


class ProdigyXYParams(TypedDict, total=False):
    group: str
    region: str
    acquisition_date: str
    analysis_method: str
    analyzer: str
    analyzer_lens: str
    analyzer_slit: str
    scan_mode: Measure_type
    curves_scan: int
    values_curve: int
    dwell_time: float
    excitation_energy: float
    kinetic_energy: float
    pass_energy: float
    bias_voltage: float
    detector_voltage: float
    eff_workfunction: float
    source: str
    comment: str
    ordinate_range: str


class ProdigyXY:
    """Class for Prodigy exported xy file.

    Args:
        list_from_xy_file(list[str] | None): list form of itx file
            (Path(itx_file).open().readlines())

    Attributes:
        params(dict[str, str | int float]): Measurement Parameters
        axis_info(dict[str, tuple[float, float, int, str]]): \
        Information of axis: start, end, num_of_points, unit
        intensity: photemission intensity
    """

    def __init__(self, list_from_xy_file: list[str] | None = None) -> None:
        """Initialize."""
        self.params: ProdigyXYParams
        self.axis_info: dict[str, tuple[float, float, int, str]] = {}
        self.intensity: NDArray
        if list_from_xy_file is not None:
            self.parse(list_from_xy_file)

    def parse(self, list_from_xy_file: list[str]) -> None:
        """Load and then parse the xy file generated by Prodigy.

        Args:
            list_from_xy_file(list[str]):list form of xy file by readlines()

        """
        xy_data = list(map(str.rstrip, list_from_xy_file))
        self.params = _parse_xy_head(xy_data)

        en_counts = np.loadtxt(list_from_xy_file, comments="#", dtype=float)

        num_of_en = self.params["values_curve"]  # energy channels
        num_of_curves = self.params["curves_scan"]  # non energy channels

        theta = []
        non_energy_ordinate = []
        count_curves = 0
        for line in xy_data:
            if line.startswith("# Parameter:"):
                key, _, value = line.partition(" = ")
                value = value.strip()
                theta.append(float(value))
            elif count_curves <= num_of_curves and line.startswith("# NonEnergyOrdinate:"):
                    key, _, value = line.partition(":")
                    value = value.strip()
                    non_energy_ordinate.append(float(value))
                    count_curves += 1

        mcp_width = -non_energy_ordinate[0] + non_energy_ordinate[-1]
        num_of_polar = len(theta)
        self.intensity = en_counts[:, 1]

        if num_of_polar == 0:
            num_of_polar = 1

        if self.params["scan_mode"] == "SnapshotFAT":
            num_of_en = self.intensity.size // (num_of_curves * num_of_polar)
        energies = en_counts[0:num_of_en, 0]
        kinetic_ef_energy = energies - self.params["excitation_energy"]

        lens_mode = self.params["analyzer_lens"].split(":")[0]
        dim_max, dispersion_mode = _parse_lens(lens_mode, mcp_width)

        # first dimension is always energy
        self.axis_info["d1"] = (float(kinetic_ef_energy[0]),
                                float(kinetic_ef_energy[-1]),
                                num_of_en,
                                "eV")
        # second dimension could be phi angle or x position on the sample in magnification modes
        if dispersion_mode:
            self.axis_info["d2"] = (-dim_max, dim_max, num_of_curves, "phi")

        else:
            self.axis_info["d2"] = (-dim_max, dim_max, num_of_curves, "x")
        # third dimension - only theta polar angle is supported now
        if num_of_polar > 1:
            # 3d map eV vs phi vs theta
            self.axis_info["d3"] = (float(np.deg2rad(theta[0])),
                                    float(np.deg2rad(theta[-1])),
                                    num_of_polar, "theta")
            self.intensity = self.intensity.reshape((num_of_polar,
                                                     num_of_curves,
                                                     num_of_en,
                                                     ))
            self.intensity = np.transpose(self.intensity, (2, 1, 0))
        else:
            # single scan only eV vs phi
            self.intensity = self.intensity.reshape((num_of_curves,
                                                     num_of_en,
                                                     ))
            self.intensity = np.transpose(self.intensity, (1, 0))

    def to_data_array(self, **kwargs: str | float) -> xr.DataArray:
        """Export to Xarray.

        Args:
            **kwargs(str | float): Extra arguments. Forward to the attrs of the output xarray.

        Returns:
            xr.DataArray: pyarpess compatibility
        """
        attrs = self.params
        coords: dict[str, NDArray[np.float_]] = {}

        # set energy axis
        energies = np.linspace(self.axis_info["d1"][0],
                               self.axis_info["d1"][1],
                               self.axis_info["d1"][2],
                               )
        coords[self.axis_info["d1"][3]] = energies
        # set second dimension phi or x
        non_energy_ordinate = np.linspace(self.axis_info["d2"][0],
                                          self.axis_info["d2"][1],
                                          self.axis_info["d2"][2],
                                          )
        coords[self.axis_info["d2"][3]] = non_energy_ordinate

        if len(self.axis_info) == THETA_MAP_DIMENSION:
            theta = np.linspace(self.axis_info["d3"][0],
                                self.axis_info["d3"][1],
                                self.axis_info["d3"][2],
                                )
            coords[self.axis_info["d3"][3]] = theta

        dims = [v[3] for v in self.axis_info.values()]

        data_array = xr.DataArray(
            np.array(self.intensity),
            coords=coords,
            dims=dims,
            attrs=attrs,
        )
        for k, v in kwargs.items():
            data_array.attrs[k] = v
        return data_array


def load_xy(
        path_to_file: Path | str,
        **kwargs: str | float,
) -> xr.DataArray | list[xr.DataArray]:
    """Load and parse the xy data.

    Args:
        path_to_file (Path | str): Path to xy file.
        kwargs (str | int | float): Treated as attrs

    Returns:
        xr.DataArray: pyARPES compatible
    """
    with Path(path_to_file).open(mode="r") as xy_file:
        xy_data: list[str] = xy_file.readlines()
        prodigy_xy = ProdigyXY(xy_data)
        array_data = prodigy_xy.to_data_array()
        for k, v in kwargs.items():
            array_data.attrs[k] = v
        return array_data


def _parse_xy_head(xy_data: list[str]) -> ProdigyXYParams:
    """Parse Common head part.

    Parameters
    ----------
    xy_data : list[str]
        Contents of xy data file (return on readlines())

    Returns:
    -------
    dict[str, str | int | float]
        Common head data
    """
    temp_params: dict[str, str | int | float] = {}
    for line in xy_data[15:]:
        if line.startswith("# Cycle"):
            break
        key, _, value = line[1:].partition(":")
        temp_params[_formatted_key(key)] = _formatted_value(value)

    common_params: ProdigyXYParams = cast(ProdigyXYParams, temp_params)

    return common_params


def _parse_lens(lens_mode: str, mcp_width: float) -> tuple[float, bool]:
    dispersion_mode = True
    lens_mapping = {
        "HighAngularDispersion": (np.deg2rad(3), True),
        "MediumAngularDispersion": (np.deg2rad(4), True),
        "LowAngularDispersion": (np.deg2rad(7), True),
        "WideAngleMode": (np.deg2rad(13), True),
        "Magnification": (mcp_width, False),
    }
    if lens_mode in lens_mapping:
        dim_max, dispersion_mode = lens_mapping[lens_mode]
    else:
        msg = f"Unknown Analyzer Lens: {lens_mode}"
        raise ValueError(msg)

    return dim_max, dispersion_mode


def _formatted_key(key: str) -> str:
    """Remove non-alphanumeric chars from key and change to snake_case."""
    key = key.strip()
    key = re.sub(r"\W", "", key)
    key = re.sub(r"(?<!^)(?=[A-Z])", "_", key)
    return key.lower()


def _formatted_value(value: str) -> int | float | str:
    value = value.strip()
    if value.isnumeric():
        return int(value)
    try:
        return float(value)
    except ValueError:
        return value

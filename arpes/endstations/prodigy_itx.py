"""pyarpes plugin for SpecsLab Prodigy."""
from __future__ import annotations

import re
from datetime import UTC, datetime
from pathlib import Path
from typing import TYPE_CHECKING, Literal

import numpy as np
import xarray as xr

if TYPE_CHECKING:
    from numpy.typing import NDArray

Measure_type = Literal["FAT", "SFAT"]
__all__ = ["load_itx", "load_sp2"]

DIGIT_ID = 3


class ProdigyItx:
    """Class for Prodigy exported itx file.

    Args:
        list_from_itx_file(list[str] | None): list form of itx file
            (Path(itx_file).open().readlines())

    Attributes:
        params(dict[str, str | int float]): Measurement Prameters
        pixels(tuple[int, int]): The number of the pixcels of the intensity map.
        axis_info(dict[str, tuple[str, float, float, str]]): Information of axis
        wavename(str): The name of wave
        intensity(list[list[float]]): Phtoemission intensity
    """

    def __init__(self, list_from_itx_file: list[str] | None = None) -> None:
        """Initialize."""
        self.params: dict[str, str | float] = {}
        self.pixels: tuple[int, int]
        self.axis_info: dict[str, tuple[str, float, float, str]] = {}
        self.wavename: str = ""
        self.intensity: list[list[float]] = []
        if list_from_itx_file is not None:
            self.parse(list_from_itx_file)

    def parse(self, list_from_itx_file: list[str]) -> None:
        """Load and then parse the itx file generated by Prodigy.

        Args:
            list_from_itx_file(list[str]):list form of itx file by readlines()

        """
        itx_data = list(map(str.rstrip, list_from_itx_file))
        self.params = _parse_itx_head(itx_data, parse_type=True)
        if itx_data.count("BEGIN") != 1:
            msg = "This itx file contains more than one spectra."
            msg += " Use the itx file that Prodigy exports."
            raise RuntimeError(msg)
        for line in itx_data:
            if line.startswith(("IGOR", "BEGIN", "END")):
                continue
            if line.startswith("X //"):
                continue
            if line.startswith("WAVES/S/N"):
                self.pixels = (
                    int(line[11:].split(")")[0].split(",")[0]),
                    int(line[11:].split(")")[0].split(",")[1]),
                )
                self.wavename = line.split(maxsplit=1)[-1].strip()[1:-1]
                continue
            if line.startswith("X SetScale"):
                tmp = _parse_setscale(line)
                self.axis_info[tmp[1]] = (tmp[0], tmp[2], tmp[3], tmp[4])
                continue
            self.intensity.append([float(i) for i in line.split()])

    def to_data_array(self, **kwargs: str | float) -> xr.DataArray:
        """Export to Xarray.

        Args:
            **kwargs(str | float):Extra arguments: forward to the attrs of the output xarray.

        Returns:
            xr.DataArray: pyarpess compatibility
        """
        common_attrs: dict[str, str | float] = {}
        common_attrs["spectrum_type"] = "cut"
        attrs = common_attrs
        coords: dict[str, NDArray] = {}
        # set angle axis
        if self.axis_info["x"][0] == "I":
            angle = np.linspace(
                float(self.axis_info["x"][1]),
                float(self.axis_info["x"][2]),
                num=self.pixels[0],
            )
            coords["phi"] = np.deg2rad(angle)
        elif self.axis_info["x"][0] == "P":
            angle = np.linspace(
                float(self.axis_info["x"][1]),
                float(self.axis_info["x"][1])
                + float(self.axis_info["x"][2]) * (self.pixels[0] - 1),
                num=self.pixels[0],
            )
            coords["phi"] = np.deg2rad(angle)
        if self.axis_info["y"][0] == "I":
            coords["eV"] = np.linspace(
                float(self.axis_info["y"][1]),
                float(self.axis_info["y"][2]),
                num=self.pixels[1],
            )
        elif self.axis_info["y"][0] == "P":
            coords["eV"] = np.linspace(
                float(self.axis_info["y"][1]),
                float(self.axis_info["y"][1])
                + float(self.axis_info["y"][2]) * (self.pixels[1] - 1),
                num=self.pixels[1],
            )
        attrs.update(self.params)
        attrs["angle_unit"] = "rad (theta_y)"
        if "y" in self.axis_info:
            attrs["enegy_unit"] = self.axis_info["y"][3]
        if "d" in self.axis_info:
            attrs["count_unit"] = self.axis_info["d"][3]
        data_array = xr.DataArray(
            np.array(self.intensity),
            coords=coords,
            dims=["phi", "eV"],
            attrs=attrs,
            name=self.wavename,
        )
        for k, v in kwargs.items():
            data_array.attrs[k] = v
        return data_array

    @property
    def integrated_intensity(self) -> float:
        """Return the integrated intensity."""
        return np.sum(np.array(self.intensity))


def convert_itx_format(arr: xr.DataArray, *, add_notes: bool = False) -> str:
    """Export pyarpes spectrum data to itx file.

    Note: that the wave name is changed based on the ID number.

    Args:
        arr(xr.DataArray):  DataArray to export
        add_notes(bool): if True, add some info to notes in wave.(default: False)

    Returns:
        str: itx formatted ARPES data
    """
    assert isinstance(arr, xr.DataArray)
    start_energy: float = arr.indexes["eV"][0]
    step_energy: float = arr.indexes["eV"][1] - arr.indexes["eV"][0]
    end_energy: float = arr.indexes["eV"][-1]
    parameters = arr.attrs
    parameters["StartEnergy"] = start_energy
    parameters["StepWidth"] = step_energy
    itx_str: str = _build_itx_header(
        arr.attrs,
        comment=arr.attrs["User Comment"],
        measure_mode=arr.attrs["Scan Mode"],
    )
    phi_pixel = len(arr.coords["phi"])
    energy_pixel = len(arr.coords["eV"])
    id_number = parameters.get("id", parameters.get("Spectrum ID"))
    wavename = "ID_" + str(id_number).zfill(DIGIT_ID)
    itx_str += f"WAVES/S/N=({phi_pixel},{energy_pixel}) '{wavename}'\nBEGIN\n"
    try:
        intensities_list = arr.to_dict()["data_vars"]["spectrum"]["data"]
    except KeyError:
        intensities_list = arr.to_dict()["data"]
    for a_intensities in intensities_list:
        itx_str += " ".join(map(str, a_intensities)) + "\n"
    itx_str += "END\n"
    if add_notes:
        itx_str = """X Note /NOCR '{}' "{}"\r\n""".format(
            wavename,
            arr.attrs["User Comment"],
        )
        excitation_energy = arr.attrs.get("hv", parameters.get("Excitation Energy"))
        itx_str = f"""X Note /NOCR '{wavename}', "Excitation Energy:{excitation_energy}"\r\n"""
        # parameter should be recorded.
        # x, y, z (if defined)
        #
    start_phi_deg: float = np.rad2deg(arr.indexes["phi"][0])
    end_phi_deg: float = np.rad2deg(arr.indexes["phi"][-1])
    itx_str += """X SetScale/I x, {}, {}, "deg (theta_y)", '{}'\n""".format(
        start_phi_deg,
        end_phi_deg,
        wavename,
    )
    itx_str += f"""X SetScale/I y, {start_energy}, {end_energy}, "eV", '{wavename}'\n"""

    itx_str += """X SetScale/I d, 0, 0, "{}", '{}'\n""".format(
        arr.attrs.get("count_unit", "cps"),
        wavename,
    )
    return itx_str


def export_itx(
    file_name: str | Path,
    arr: xr.DataArray,
    *,
    add_notes: bool = False,
) -> None:
    """Export pyarpes spectrum data to itx file.

    Args:
        file_name(str | Path): file name for export
        arr(xr.DataArray): pyarpes DataArray
        add_notes(bool): if True, add some infor to notes in wave (default: False)

    Returns:
        str: itx formatted ARPES data
    """
    with Path(file_name).open(mode="w") as itx_file:
        itx_file.write(convert_itx_format(arr, add_notes=add_notes))


def load_itx(
    path_to_file: Path | str,
    **kwargs: str | float,
) -> xr.DataArray | list[xr.DataArray]:
    """Load and parse the itx data.

    Args:
        path_to_file(Path | str): Path to itx file.
        kwargs (str | int | float): Treated as attrs

    Returns:
        xr.DataArray: pyARPES compatible
    """

    def find_indices(
        list_to_check: list[str],
        str_to_find: str = "",
    ) -> list[int]:
        """Get index of All Occurrences of Element in a Python List.

        Args:
            list_to_check(list[str]): list for check
            str_to_find(str): string to find, default to "".

        Returns:
            list[int]: the list of all indexes.
        """
        return [idx for idx, value in enumerate(list_to_check) if value == str_to_find]

    with Path(path_to_file).open(mode="r") as itx_file:
        itx_data: list[str] = itx_file.readlines()
        itx_data = list(map(str.rstrip, itx_data))
        if itx_data.count("BEGIN") == 1:
            prodigy_itx = ProdigyItx(itx_data)
            data = prodigy_itx.to_data_array()
            for k, v in kwargs.items():
                data.attrs[k] = v
            return data
        end_index_list = [*find_indices(itx_data, ""), -1]
        slice_list = []
        for i in range(len(end_index_list)):
            if i == 0:
                slice_list.append(slice(0, end_index_list[0]))
            else:
                slice_list.append(slice(end_index_list[i - 1], end_index_list[i]))
        multi_itx_data = []
        for sl in slice_list:
            a_itx_data = ProdigyItx(itx_data[sl]).to_data_array()
            for k, v in kwargs.items():
                a_itx_data[k] = v
            multi_itx_data.append(a_itx_data)
        return multi_itx_data


def load_sp2(
    path_to_file: Path | str,
    **kwargs: str | float,
) -> xr.DataArray:
    """Load and parse sp2 file.

    Args:
        path_to_file(Path | str): Path to sp2 file
        kwargs(str | int | float): Treated as attrs

    Returns:
        xr.DataArray: pyARPES compatible
    """
    params: dict[str, str | float] = {}
    data: list[float] = []
    pixels: tuple[int, int] = (0, 0)
    coords: dict[str, NDArray] = {}
    with Path(path_to_file).open(encoding="Windows-1252") as sp2file:
        for line in sp2file:
            if line.startswith("#"):
                params = _parse_sp2_comment(line, params)
            elif line.startswith("P"):
                pass
            elif pixels != (0, 0):
                data.append(float(line))
            else:
                pixels = (
                    int(line.split()[1]),
                    int(line.split()[0]),
                )
    if pixels != (0, 0):
        if isinstance(params["X Range"], str):
            e_range = [float(i) for i in re.findall(r"-?[0-9]+\.?[0-9]*", params["X Range"])]
            coords["eV"] = np.linspace(e_range[0], e_range[1], pixels[1])
        if isinstance(params["Y Range"], str):
            a_range = [float(i) for i in re.findall(r"-?[0-9]+\.?[0-9]*", params["Y Range"])]
            corrected_angles = _correct_angle_region(a_range[0], a_range[1], pixels[0])

            coords["phi"] = np.deg2rad(
                np.linspace(corrected_angles[0], corrected_angles[1], pixels[0]),
            )
    params["spectrum_type"] = "cut"
    data_array: xr.DataArray = xr.DataArray(
        np.array(data).reshape(pixels),
        coords=coords,
        dims=["phi", "eV"],
        attrs=params,
    )
    for k, v in kwargs.items():
        data_array.attrs[k] = v
    return data_array


def _parse_sp2_comment(line: str, params: dict[str, str | float]) -> dict[str, str | float | int]:
    try:
        params[line[2:].split("=", maxsplit=1)[0].strip()] = int(
            line[2:].split("=", maxsplit=1)[1].strip(),
        )
    except ValueError:
        try:
            params[line[2:].split("=", maxsplit=1)[0].strip()] = float(
                line[2:].split("=", maxsplit=1)[1].strip(),
            )
        except ValueError:
            params[line[2:].split("=", maxsplit=1)[0].strip()] = (
                line[2:].split("=", maxsplit=1)[1].strip()
            )
    except IndexError:
        pass
    return params


header_template = """IGOR
X //Created Date (UTC): {}
X //Created by: R. Arafune
X //Acquisition Parameters:
X //Scan Mode         = {}
X //User Comment      = {}
X //Analysis Mode     = UPS
X //Lens Mode         = {}
X //Lens Voltage      = {}
X //Spectrum ID       = {}
X //Analyzer Slits    = {}
X //Number of Scans   = {}
X //Number of Samples = {}
X //Scan Step         = {}
X //DwellTime         = {}
X //Excitation Energy = {}
X //Kinetic Energy    = {}
X //Pass Energy       = {}
X //Bias Voltage      = {}
X //Detector Voltage  = {}
X //WorkFunction      = {}
"""


def _build_itx_header(
    param: dict,
    comment: str = "",
    measure_mode: Measure_type = "FAT",
) -> str:
    """Make itx file header.

    Parameters
    ----------
    param: dict[ str, str | float | int]
        Spectrum parameter
    spectrum_id: int
        Unique id for spectrum
    num_scan: int
        Number of scan.
    comment: str
        Comment string.  Used in "//User Comment"
    measure_mode : Measure_type
        Measurement mode (FAT/SFAT)

    Returns:
    -------
    str
        Header part of itx
    """
    mode = "Fixed Analyzer Transmission" if measure_mode == "FAT" else "Snapshot"
    now = datetime.now(UTC).strftime("%Y-%m-%d %H:%M:%S.%f")
    if param["User Comment"]:
        comment += ";" + param["User Comment"]
    return header_template.format(
        now,
        mode,
        param["User Comment"],
        param.get("lens_mode", param.get("Lens Mode")),
        param["Lens Voltage"],
        param.get("id", param.get("Spectrum ID")),
        param["Analyzer Slits"],
        param["Number of Scans"],
        param["Number of Samples"],
        param["StepWidth"],
        param["DwellTime"],
        param.get("hv", param.get("Excitation Energy")),
        param["StartEnergy"],
        param.get("pass_energy", param.get("Pass Energy", 5)),
        param["Bias Voltage"],
        param.get("mcp_voltage", param.get("Detector Voltage")),
        param.get("workfunction", param.get("WorkFunction", 4.401)),
    )


def _correct_angle_region(
    angle_min: float,
    angle_max: float,
    num_pixel: int,
) -> tuple[float, float]:
    """Correct the angle value to fit igor.

    Parameters
    ----------
    angle_min: float
        Minimum angle of emission
    angle_max: float
        Maximum angle of emission
    num_pixel: int
        The number of pixels for non-energy channels (i.e. angle)

    Returns:
    -------
    tuple[float, float]
        minimum angle value and maximum angle value
    """
    diff: float = ((angle_max - angle_min) / num_pixel) / 2
    return angle_min + diff, angle_max - diff


def _parse_itx_head(
    itx_data: list[str],
    *,
    parse_type: bool = False,
) -> dict[str, str | int | float]:
    """Parse Common head part.

    Parameters
    ----------
    itx_data : list[str]
        Contents of itx data file (return on readlines())
    parse_type: bool
        if true the type of the value in head part is analyzed.

    Returns:
    -------
    dict[str, str | int | float]
        Common head data
    """
    common_params: dict[str, str | int | float] = {}
    for line in itx_data[1:]:
        if not line.startswith("X //") or line.startswith("X //Acquisition Parameters"):
            continue
        if line.startswith("X //User Comment"):
            common_params = _parse_user_comment(line, common_params)
        elif "=" in line:
            line_data = line[4:].split("=", maxsplit=1)
            common_params[line_data[0].strip()] = line_data[1].strip()
        elif ":" in line:
            line_data = line.split(":", maxsplit=1)
            common_params[line_data[0][4:].strip()] = line_data[1].strip()
    if parse_type:
        common_params = _parse_type(common_params)
    return common_params


def _parse_type(
    common_params: dict[str, str | int | float],
) -> dict[str, str | int | float]:
    """Parse type in common params.

    Helper function to parse the type of the value in common params

    Parameters
    ----------
    common_params: dict[str, str | int | flaot]
        commmon params to be parsed

    Returns:
    -------
    dict[str, str | int | float]
        parsed common_params
    """
    for k, v in common_params.items():
        try:
            common_params[k] = int(v)
        except ValueError:  # noqa: PERF203
            try:
                common_params[k] = float(v)
            except ValueError:
                common_params[k] = v
    return common_params


def _parse_user_comment(
    line: str,
    common_params: dict[str, str | int | float],
) -> dict[str, str | int | float]:
    """Parse "USER COMMENT" line.

    Helper function: Treating the USER COMMENT

    Parameters
    ----------
    line: str
        line stringl
    common_params: dict[str, str| int, float]
        common parameters

    Returns:
    -------
    dict[str, str| int|float]
        common parameters including "User COMMENT" information
    """
    user_comment: str = line.split("=", maxsplit=1)[1].strip()
    common_params["User Comment"] = str(common_params.get("User Comment", "")) + user_comment
    line_data: list[str] = user_comment.split(";", maxsplit=1)
    for item in line_data:
        try:
            key, value = item.split(":")
            common_params[key] = value
        except ValueError:  # noqa: PERF203
            pass
    return common_params


def _parse_setscale(line: str) -> tuple[str, str, float, float, str]:
    """Parse setscale.

    Args:
        line(str): line should start with "X SetScale"

    Returns:
        tuple[str, str, float, float, str]
    """
    assert "SetScale" in line
    flag: str
    dim: str
    num1: float
    num2: float
    unit: str
    setscale = line.split(",", maxsplit=5)
    if "/I" in line:
        flag = "I"
    elif "/P" in line:
        flag = "P"
    else:
        flag = ""
    if "x" in setscale[0]:
        dim = "x"
    elif "y" in setscale[0]:
        dim = "y"
    elif "z" in setscale[0]:
        dim = "z"
    elif "d" in setscale[0]:
        dim = "d"
    elif " t" in setscale[0]:
        dim = "t"
    else:
        msg = "Dimmension is not correct"
        raise RuntimeError(msg)
    unit = setscale[3].strip()[1:-1]
    num1 = float(setscale[1])
    num2 = float(setscale[2])
    return (flag, dim, num1, num2, unit)

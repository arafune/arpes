"""pyarpes plugin for SpecsLab Prodigy exported .xy files.

Currently, this plugin supports following scenarios:
1. Single scan dispersion modes eV vs phi angle.
2. Single scan magnification modes eV vs x.
3. 3D maps: counts as a function of eV, phi, and a third parameter.

First dimension is always energy. It is stored as a first column of the xy data.

Second dimension "nonenegy" is perpendicular to the energy on the MCP detector,
stored as # NonEnergyOrdinate in each block of the data.
This could be both: angular (phi angle) or spacial (along the slit direction).

Third dimension/parameter could be:
- the deflector shift (psi angle)
- manipulator rotation (theta angle).
- other parameter: the details should be provided in specific end station plugin.
The third dimension is stored with an original name found in xy file (Parameter).
"""

from __future__ import annotations

import re
from pathlib import Path
from typing import TYPE_CHECKING, Literal, TypedDict, cast

import numpy as np
import xarray as xr

from arpes.utilities import clean_keys

if TYPE_CHECKING:
    from numpy.typing import NDArray

MAP_DIMENSION = 3
SECOND_DIM_NAME = "nonenergy"

Measure_type = Literal["FAT", "SnapshotFAT", "Magnification"]
__all__ = ["load_xy"]


class ProdigyXYParams(TypedDict, total=False):
    group: str
    region: str
    acquisition_date: str
    analysis_method: str
    analyzer: str
    analyzer_lens: str
    analyzer_slit: str
    scan_mode: Measure_type
    curves_scan: int
    values_curve: int
    dwell_time: float
    excitation_energy: float
    kinetic_energy: float
    pass_energy: float
    bias_voltage: float
    detector_voltage: float
    eff_workfunction: float
    source: str
    comment: str
    ordinate_range: str


class ProdigyXY:
    """Class for Prodigy exported xy file.

    Args:
        list_from_xy_file(list[str] | None): list form of xy file
            (Path(xy_file).open().readlines())

    Attributes:
        params(dict[str, str | int float]): Measurement Parameters
        axis_info(dict[str, tuple[NDArray, str]]):
        Information about all axes:
        key=d1,d2,d3 (values and name)
        intensity: photemission intensity
    """

    def __init__(self, list_from_xy_file: list[str] | None = None) -> None:
        """Initialize."""
        self.params: ProdigyXYParams = cast(ProdigyXYParams, {})
        self.axis_info: dict[str, tuple[NDArray[np.float_], str]] = {}
        self.intensity: NDArray[np.float_]
        if list_from_xy_file is not None:
            self.parse(list_from_xy_file)

    def parse(self, list_from_xy_file: list[str]) -> None:
        """Load and then parse the xy file generated by Prodigy.

        Args:
            list_from_xy_file(list[str]):list form of xy file by readlines()

        """
        # create separate list that contains only commented lines (starting with #)
        xy_data_params = [line.strip() for line in list_from_xy_file if line.startswith("#")]
        en_counts = np.loadtxt(list_from_xy_file, comments="#", dtype=float)
        energies = en_counts[:, 0]
        self.intensity = en_counts[:, 1]

        self.params = _parse_xy_head(xy_data_params)
        # search for second and third dimension values and names
        xy_dims = _parse_xy_dims(xy_data_params)

        dim_names = list(xy_dims.keys())
        dim_values = list(xy_dims.values())

        second_dim_name: str = str(dim_names[0])
        second_dim_values = dim_values[0]
        third_dim_name: str = str(dim_names[1])
        third_dim_values = dim_values[1]

        num_of_second = len(second_dim_values)
        num_of_third = 1 if len(third_dim_values) == 0 else len(third_dim_values)

        if self.params["scan_mode"] == "SnapshotFAT":
            num_of_en = len(self.intensity) // (num_of_second * num_of_third)
        else:
            num_of_en = self.params["values_curve"]

        kinetic_ef_energy = energies[0:num_of_en]
        # first dimension is always energy
        self.axis_info["d1"] = (kinetic_ef_energy, "eV")
        # second dimension could be phi angle or x position on the sample in magnification modes
        self.axis_info["d2"] = (second_dim_values, second_dim_name)
        # third dimension - polar angle of the manipulator od deflector shift - psi angle
        if num_of_third > 1:
            # 3d map eV vs phi vs parameter
            self.axis_info["d3"] = (third_dim_values, third_dim_name)
            self.intensity = self.intensity.reshape(
                (
                    num_of_third,
                    num_of_second,
                    num_of_en,
                ),
            )
            self.intensity = np.transpose(self.intensity, (2, 1, 0))
        else:
            # single scan only eV vs phi
            self.intensity = self.intensity.reshape(
                (
                    num_of_second,
                    num_of_en,
                ),
            )
            self.intensity = np.transpose(self.intensity, (1, 0))

    def to_data_array(self, **kwargs: str | float) -> xr.DataArray:
        """Export to Xarray.

        Args:
            **kwargs(str | float): Extra arguments. Forward to the attrs of the output xarray.

        Returns:
            xr.DataArray: pyarpess compatibility
        """
        attrs = self.params
        coords: dict[str, NDArray[np.float_]] = {}
        # set energy axis
        coords[self.axis_info["d1"][1]] = self.axis_info["d1"][0]
        # set second dimension - non energy ordinate
        coords[self.axis_info["d2"][1]] = self.axis_info["d2"][0]
        # set third dimension
        if len(self.axis_info) == MAP_DIMENSION:
            coords[self.axis_info["d3"][1]] = np.deg2rad(self.axis_info["d3"][0])

        dims = [v[1] for v in self.axis_info.values()]
        data_array = xr.DataArray(
            np.array(self.intensity),
            coords=coords,
            dims=dims,
            attrs=attrs,
        )
        for k, v in kwargs.items():
            data_array.attrs[k] = v
        return data_array

    @property
    def integrated_intensity(self) -> float:
        """Return the integrated intensity."""
        return np.sum(np.array(self.intensity))


def load_xy(
        path_to_file: Path | str,
        **kwargs: str | float,
) -> xr.DataArray:
    """Load and parse the xy data.

    Args:
        path_to_file (Path | str): Path to xy file.
        kwargs (str | int | float): Treated as attrs

    Returns:
        xr.DataArray: pyARPES compatible
    """
    with Path(path_to_file).open(mode="r") as xy_file:
        xy_data: list[str] = xy_file.readlines()
        prodigy_xy = ProdigyXY(xy_data)
        data_array = prodigy_xy.to_data_array()
        for k, v in kwargs.items():
            data_array.attrs[k] = v
        return data_array


def _parse_xy_head(xy_data_params: list[str]) -> ProdigyXYParams:
    """Parse Common head part.

    Parameters
    ----------
    xy_data_params : list[str]
        Comment lines, starting with #, of the xy data file

    Returns:
    -------
    dict[str, str | int | float]
        Common head data
    """
    temp_params: dict[str, str | int | float] = {}
    start_ind = 0
    for line in xy_data_params:
        if line.startswith("# Group:"):
            break
        start_ind += 1

    for line in xy_data_params[start_ind:]:
        if line.startswith("# Cycle"):
            break
        key, _, value = line[1:].partition(":")
        temp_params[key.strip()] = _formatted_value(value)
    common_params: ProdigyXYParams = cast(ProdigyXYParams, clean_keys(temp_params))
    return common_params


def _parse_xy_dims(xy_data_params: list[str]) -> dict[str, NDArray[np.float_]]:
    """Parse other than energy dimensions.

    Args:
        xy_data_params: list[str]
        Comment lines, starting with #, of the xy data file

    Returns:
        Dictionary with the second and the third dimension values
        where the key is the name of the dimension
    """
    xy_dims: dict[str, NDArray[np.float_]] = {}

    second_dim_done: bool = False
    second_dim: list[float] = []
    second_name: str = SECOND_DIM_NAME
    third_dim: list[float] = []
    third_dim_count: int = 0
    third_dim_name: str = "thirddim"

    paramexpr = re.compile(r"# Parameter:\s\"(\w+)\s.+\s=\s(-?\d+.?\d*)")
    nonenergyexpr = re.compile(r"# NonEnergyOrdinate:\s+(-?\d+.?\d*)")

    for line in xy_data_params:
        # Use nested conditions for better performance
        # Search for Parameter line
        m = paramexpr.match(line)
        if m:
            third_dim.append(float(m.group(2)))
            # Capture the parameter name. Could be for example polar [deg] or deflector [x]
            if third_dim_count == 0:
                third_dim_name = str(m.group(1)).strip()
            third_dim_count += 1
        if not second_dim_done:
            m = nonenergyexpr.match(line)
            if m:
                nonenergy = float(m.group(1))
                second_dim.append(nonenergy)
                if len(second_dim) > 1 and nonenergy == second_dim[0]:
                    second_dim.pop()
                    second_dim_done = True

    second_dim_values = np.array(second_dim)
    third_dim_values = np.array(third_dim)
    xy_dims[second_name] = second_dim_values
    xy_dims[third_dim_name] = third_dim_values

    return clean_keys(xy_dims)


def _formatted_value(value: str) -> int | float | str:
    value = value.strip()
    if value.isnumeric():
        return int(value)
    try:
        return float(value)
    except ValueError:
        return value
